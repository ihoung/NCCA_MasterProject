<fragment  uiName="ETS_ShadingMapFragment" name="ETS_ShadingMapFragment" type="plumbing" class="ShadeFragment" version="1.0" feature_level="30" >
    <description>
<![CDATA[
Toon renderer. Uses pre-processed shade map to render the final shading color.]]>
    </description>
    <properties>
        <float3  name="Pw" flags="varyingInputParam" />
        <float3 name="Nw" flags="varyingInputParam" />
        <float3 name="Lw" />
        <float  name="ShadeThreshold" />
        <float  name="DiffuseSmoothness" />
        <float  name="influenceDistance" />
        <int name="editNum" />
        <float4x4  name="editLightSpace" size="50" />
        <float3  name="editWorldPosition" size="50" />
        <float3  name="originWorldPosition" size="50" />
        <float  name="anisotropy" size="50" />
        <float  name="sharpness" size="50" />
        <float  name="bend" size="50" />
        <float  name="bulge" size="50" />
        <float  name="rotation" size="50" />
        <float  name="normalSmooth" size="50" />
        <float  name="intensityGain" size="50" />
        <float  name="softness" size="50" />
    </properties>
    <values>
        <float3 name="Lw" value="0.0,0.0,0.0" />
        <float name="ShadeThreshold" value="0.500000" />
        <float name="DiffuseSmoothness" value="0.400000" />
        <int name="editNum" value="0" />
    </values>
    <outputs>
        <float3 name="output" />
    </outputs>
    <parametershare>
    </parametershare>
    <implementation >
    <implementation render="OGSRenderer" language="Cg" lang_version="2.100000" >
        <function_name val="ETSShadingMapFragment" />
        <source>
            <![CDATA[
float2x2 rot2D(float rad)
{
    return float2x2(cos(rad), -sin(rad), sin(rad), cos(rad));
}
float2 getTexSpaceUV(float3 Pw, float3 ewp, float4x4 els)
{
    float PI = radians(180);

    float3 lsVec = mul(normalize(Pw - ewp), float3x3(els));
    lsVec = normalize(lsVec);
    float lsR = acos(lsVec.z) / PI;
    float lsTh = atan(lsVec.y / lsVec.x);
    float pu = lsR * cos(lsTh);
    float pv = lsR * sin(lsTh);
    return float2(pu, pv);
}
float warppedIntensity(float2 uv, float a,float s,float wy,float wx,float rot)
{
    float PI = radians(180);
    float2 w = float2(wy, wx);
    float thw = 10.0f * dot(w, mul(uv, rot2D(rot)));
    if (thw <= -PI/2.0f || thw >= PI/2.0f) return 0.0f;
    float2 UVw = w + mul(mul(uv, rot2D(rot)) - w, rot2D(thw));
    return exp(-a * exp2(UVw.x) - 1.0f / a * pow(abs(UVw.y), 2-s));
}
float distanceWeight(float R, float3 Pw, float3 ewp)
{
    return smoothstep(0.0f, 1.0f, 20.0f * (R - distance(Pw, ewp)));
}
float normalSmoothWeight(float3 Pw, float3 Nw, float3 ewp, float3 owp, float ns)
{
    float3 n_ = (1-ns)*Nw + ns*normalize(Pw-owp);
    return dot(normalize(n_), normalize(Pw - ewp));
}
float3 ETSShadingMapFragment(
    float3 Pw,
    float3 Nw,
    float3 Lw,
    float ShadeThreshold,
    float DiffuseSmoothness,
    float influenceDistance,
    int editNum,
    float4x4 editLightSpace[50],
    float3 editWorldPosition[50],
    float3 originWorldPosition[50],
    float anisotropy[50],
    float sharpness[50],
    float bend[50],
    float bulge[50],
    float rotation[50],
    float normalSmooth[50],
    float intensityGain[50],
    float softness[50]
)
{
    float intensAccum = 0.0f;
    float maskAccum = 0.0f;
    for(int i=0; i<editNum; i++)
    {
        float2 texSpaceUV = getTexSpaceUV(Pw, editWorldPosition[i], editLightSpace[i]);
        float wi = warppedIntensity(texSpaceUV,anisotropy[i],sharpness[i],bend[i],bulge[i],rotation[i]);
        float dw = distanceWeight(influenceDistance, Pw, editWorldPosition[i]);
        float nsw = normalSmoothWeight(Pw, Nw, editWorldPosition[i],originWorldPosition[i],normalSmooth[i]);
        float calIn = wi * dw * nsw;
        if (softness[i] == 0.0f)
            intensAccum += intensityGain[i] * calIn;
        else
            maskAccum = max(maskAccum, smoothstep(0.0f, 1.0f, (calIn-0.8f)/softness[i]));
    }
    float diffuse = dot(Nw, Lw) + intensAccum;
    float diffuseSmooth = pow(DiffuseSmoothness, 5);
    float smoothedDiffuse = smoothstep(ShadeThreshold-diffuseSmooth, ShadeThreshold+diffuseSmooth, diffuse);
    float intensity = lerp(0.0f, 1.0f, smoothedDiffuse);
    float result = smoothstep(0.0f, 1.0f, intensity+maskAccum);
    return float3(result, 1.0f, 1.0f);
}
            ]]>
        </source>
    </implementation>
    <implementation render="OGSRenderer" language="HLSL" lang_version="11.000000" >
        <function_name val="ETSShadingMapFragment" />
        <source>
            <![CDATA[
float2x2 rot2D(float rad)
{
    return float2x2(cos(rad), -sin(rad), sin(rad), cos(rad));
}
float editDiffuse(float3 Pw,float3 Nw,
    float4x4 els,float3 ewp,float3 owp,
    float a,float s,float wy,float wx,
    float rot,float R,float ns)
{
    float PI = radians(180);

    float3 det = normalize(Pw - ewp);
    float3 lsVec = mul(det, float3x3(els));
    lsVec = normalize(lsVec);
    float lsR = 1.0f / cos(lsVec.z);
    float lsTh = 1.0f / tan(lsVec.y / lsVec.x);
    float pu = lsR * cos(lsTh);
    float pv = lsR * sin(lsTh);
    float2 pUV = float2(pu, pv);

    float2 w = float2(wy, wx);
    float thw = 10.0f * dot(w, mul(pUV, rot2D(rot)));
    float2 UVw = w + mul(mul(pUV, rot2D(rot)) - w, rot2D(thw));
    float Iw = exp(-a * exp2(UVw.x) - 1.0f / a * pow(abs(UVw.y), 2-s));

    float cTh = 1.0f;
    if (thw <= -PI/2.0f || thw >= PI/2.0f) cTh = 0.0f;

    float weight = smoothstep(0.0f, 1.0f, 20.0f * (R - distance(Pw, ewp)));

    float3 n_ = (1-ns)*Nw + ns*normalize(Pw-owp);
    float gammaW = dot(normalize(n_), det);

    return cTh * weight * gammaW * Iw;
}
float3 ETSShadingMapFragment(
    float3 Pw,
    float3 Nw,
    float3 Lw,
    float ShadeThreshold,
    float DiffuseSmoothness,
    float influenceDistance,
    int editNum,
    float4x4 editLightSpace[50],
    float3 editWorldPosition[50],
    float3 originWorldPosition[50],
    float anisotropy[50],
    float sharpness[50],
    float bend[50],
    float bulge[50],
    float rotation[50],
    float normalSmooth[50],
    float intensityGain[50],
    float softness[50]
)
{
    float diffuse = dot(Nw, Lw);
    float diffuseSmooth = pow(DiffuseSmoothness, 5);
    float smoothedDiffuse = smoothstep(ShadeThreshold-diffuseSmooth, ShadeThreshold+diffuseSmooth, diffuse);
    float result = lerp(0.0f, 1.0f, smoothedDiffuse);
    return float3(result, 1.0f, 1.0f);
}
            ]]>
        </source>
    </implementation>
    <implementation render="OGSRenderer" language="GLSL" lang_version="3.000000" >
        <function_name val="ETSShadingMapFragment" />
        <source>
            <![CDATA[
mat2 rot2D(float rad)
{
    return mat2(cos(rad), -sin(rad), sin(rad), cos(rad));
}
float editDiffuse(
    vec3 Pw,vec3 Nw,
    mat4 els,vec3 ewp,vec3 owp,
    float a,float s,float wy,float wx,
    float rot,float R,float ns
)
{
    float PI = radians(180);

    vec3 det = normalize(Pw - ewp);
    vec3 lsVec = mul(det, float3x3(els));
    lsVec = normalize(lsVec);
    float lsR = 1.0f / cos(lsVec.z);
    float lsTh = 1.0f / tan(lsVec.y / lsVec.x);
    float pu = lsR * cos(lsTh);
    float pv = lsR * sin(lsTh);
    vec2 pUV = float2(pu, pv);

    vec2 w = vec2(wy, wx);
    float thw = 10.0f * dot(w, mul(pUV, rot2D(rot)));
    vec2 UVw = w + mul(mul(pUV, rot2D(rot)) - w, rot2D(thw));
    float Iw = exp(-a * exp2(UVw.x) - 1.0f / a * pow(abs(UVw.y), 2-s));

    float cTh = 1.0f;
    if (thw <= -PI/2.0f || thw >= PI/2.0f) cTh = 0.0f;

    float weight = smoothstep(0.0f, 1.0f, 20.0f * (R - distance(Pw, ewp)));

    vec3 n_ = (1-ns)*Nw + ns*normalize(Pw-owp);
    float gammaW = dot(normalize(n_), det);

    return cTh * weight * gammaW * Iw;
}
vec3 ETSShadingMapFragment(
    float3 Pw,
    float3 Nw,
    vec3 Lw,
    float ShadeThreshold,
    float DiffuseSmoothness,
    float influenceDistance,
    int editNum,
    mat4 editLightSpace[50],
    vec3 editWorldPosition[50],
    vec3 originWorldPosition[50],
    float anisotropy[50],
    float sharpness[50],
    float bend[50],
    float bulge[50],
    float rotation[50],
    float normalSmooth[50],
    float intensityGain[50],
    float softness[50]
)
{
    float diffuse = dot(Nw, Lw);
    float diffuseSmooth = pow(DiffuseSmoothness, 5);
    float smoothedDiffuse = smoothstep(ShadeThreshold-diffuseSmooth, ShadeThreshold+diffuseSmooth, diffuse);
    float result = lerp(0.0f, 1.0f, smoothedDiffuse);
    return vec3(result, 1.0f, 1.0f);
}
            ]]>
        </source>
    </implementation>
    </implementation>
</fragment>

